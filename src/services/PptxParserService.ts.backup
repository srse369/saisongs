import PizZip from 'pizzip';
import type { ImageElement, TextElement, VideoElement, BackgroundElement, TemplateSlide } from '../types';

interface ParsedSlide {
  background?: {
    type: 'solid' | 'image';
    value: string;
    imageData?: string; // base64 or blob URL
  };
  images: Array<{
    id: string;
    imageData: string;
    x: number;
    y: number;
    width: number;
    height: number;
    rotation?: number;
  }>;
  textBoxes: Array<{
    id: string;
    content: string;
    x: number;
    y: number;
    width: number;
    height: number;
    fontSize?: number;
    fontFamily?: string;
    color?: string;
    bold?: boolean;
    italic?: boolean;
    align?: 'left' | 'center' | 'right';
    rotation?: number;
  }>;
  videos: Array<{
    id: string;
    videoData: string;
    x: number;
    y: number;
    width: number;
    height: number;
  }>;
  width: number;
  height: number;
}

interface PptxDimensions {
  width: number;
  height: number;
  aspectRatio: '16:9' | '4:3';
}

export class PptxParserService {
  private zip: PizZip | null = null;
  private slideRelationships: Map<string, Map<string, string>> = new Map();
  private mediaFiles: Map<string, string> = new Map(); // relationId -> base64 data

  /**
   * Parse a PowerPoint file from a File object
   */
  async parsePptxFile(file: File): Promise<{
    slides: ParsedSlide[];
    dimensions: PptxDimensions;
  }> {
    const arrayBuffer = await file.arrayBuffer();
    return this.parsePptxBuffer(arrayBuffer);
  }

  /**
   * Parse a PowerPoint file from an ArrayBuffer
   */
  parsePptxBuffer(buffer: ArrayBuffer): {
    slides: ParsedSlide[];
    dimensions: PptxDimensions;
  } {
    this.zip = new PizZip(buffer);
    
    // Get presentation dimensions
    const dimensions = this.getPresentationDimensions();
    
    // Extract all media files first
    this.extractMediaFiles();
    
    // Get slide count
    const slideCount = this.getSlideCount();
    
    // Parse all slides
    const slides: ParsedSlide[] = [];
    for (let i = 1; i <= slideCount; i++) {
      const slide = this.parseSlide(i, dimensions);
      slides.push(slide);
    }
    
    return { slides, dimensions };
  }

/**
 * Get presentation dimensions from presentation.xml
 */
private getPresentationDimensions(): PptxDimensions {
  const presentationXml = this.zip?.file('ppt/presentation.xml')?.asText();
  if (!presentationXml) {
    // Default to 16:9
    return { width: 9144000, height: 5143500, aspectRatio: '16:9' };
  }

  const doc = this.parseXml(presentationXml);
  const sldSz = doc.querySelector('sldSz');
  
  if (sldSz) {
    const width = parseInt(sldSz.getAttribute('cx') || '9144000');
    const height = parseInt(sldSz.getAttribute('cy') || '5143500');
    const ratio = width / height;
    const aspectRatio = Math.abs(ratio - 16/9) < Math.abs(ratio - 4/3) ? '16:9' : '4:3';
    
    return { width, height, aspectRatio };
  }

  return { width: 9144000, height: 5143500, aspectRatio: '16:9' };
}  /**
   * Get the number of slides in the presentation
   */
  private getSlideCount(): number {
    const files = Object.keys(this.zip?.files || {});
    const slideFiles = files.filter(f => f.match(/^ppt\/slides\/slide\d+\.xml$/));
    return slideFiles.length;
  }

  /**
   * Extract all media files (images, videos) from the pptx
 */
private extractMediaFiles(): void {
  const files = Object.keys(this.zip?.files || {});
  
  // Extract images
  const imageFiles = files.filter(f => f.match(/^ppt\/media\/image\d+\.(png|jpg|jpeg|gif|bmp)$/i));
  for (const imagePath of imageFiles) {
    const imageData = this.zip?.file(imagePath)?.asUint8Array();
    if (imageData) {
      const base64 = this.uint8ArrayToBase64(imageData);
      const ext = imagePath.split('.').pop()?.toLowerCase() || 'png';
      const mimeType = ext === 'png' ? 'image/png' : ext === 'gif' ? 'image/gif' : 'image/jpeg';
      const dataUrl = `data:${mimeType};base64,${base64}`;
      
      // Store with filename as key
      const filename = imagePath.split('/').pop() || '';
      this.mediaFiles.set(filename, dataUrl);
    }
  }

  // Extract videos
  const videoFiles = files.filter(f => f.match(/^ppt\/media\/media\d+\.(mp4|mov|avi|wmv)$/i));
  for (const videoPath of videoFiles) {
    const videoData = this.zip?.file(videoPath)?.asUint8Array();
    if (videoData) {
      const base64 = this.uint8ArrayToBase64(videoData);
      const ext = videoPath.split('.').pop()?.toLowerCase() || 'mp4';
      const mimeType = `video/${ext}`;
      const dataUrl = `data:${mimeType};base64,${base64}`;
      
      const filename = videoPath.split('/').pop() || '';
      this.mediaFiles.set(filename, dataUrl);
    }
  }
}  /**
   * Parse slide relationships to map rId to media files
   */
  private async parseSlideRelationships(slideNumber: number): Promise<Map<string, string>> {
    const relsPath = `ppt/slides/_rels/slide${slideNumber}.xml.rels`;
    const relsXml = this.zip?.file(relsPath)?.asText();
    
    const relationships = new Map<string, string>();
    
    if (!relsXml) {
      return relationships;
    }

    const result = await this.parseXml(relsXml);
    const rels = result?.Relationships?.Relationship || [];
    
    for (const rel of rels) {
      const id = rel.$.Id;
      const target = rel.$.Target;
      
      if (target) {
        // Extract filename from target (e.g., "../media/image1.png" -> "image1.png")
        const filename = target.split('/').pop() || '';
        relationships.set(id, filename);
      }
    }
    
    return relationships;
  }

  /**
   * Parse a single slide
   */
  private async parseSlide(slideNumber: number, dimensions: PptxDimensions): Promise<ParsedSlide> {
    const slideXml = this.zip?.file(`ppt/slides/slide${slideNumber}.xml`)?.asText();
    
    if (!slideXml) {
      return {
        images: [],
        textBoxes: [],
        videos: [],
        width: dimensions.width,
        height: dimensions.height,
      };
    }

    // Parse relationships for this slide
    const relationships = await this.parseSlideRelationships(slideNumber);
    this.slideRelationships.set(`slide${slideNumber}`, relationships);

    const result = await this.parseXml(slideXml);
    const slide = result?.['p:sld'];
    
    if (!slide) {
      return {
        images: [],
        textBoxes: [],
        videos: [],
        width: dimensions.width,
        height: dimensions.height,
      };
    }

    // Parse background
    const background = await this.parseBackground(slide, slideNumber);

    // Parse shapes (images, text, videos)
    const shapes = slide?.['p:cSld']?.[0]?.['p:spTree']?.[0] || {};
    
    const images = await this.parseImages(shapes, slideNumber);
    const textBoxes = this.parseTextBoxes(shapes);
    const videos = await this.parseVideos(shapes, slideNumber);

    return {
      background,
      images,
      textBoxes,
      videos,
      width: dimensions.width,
      height: dimensions.height,
    };
  }

  /**
   * Parse slide background
   */
  private async parseBackground(slide: any, slideNumber: number): Promise<ParsedSlide['background']> {
    const bg = slide?.['p:cSld']?.[0]?.['p:bg']?.[0];
    
    if (!bg) {
      return undefined;
    }

    // Check for solid fill
    const solidFill = bg?.['p:bgPr']?.[0]?.['a:solidFill']?.[0];
    if (solidFill) {
      const color = this.extractColor(solidFill);
      if (color) {
        return {
          type: 'solid',
          value: color,
        };
      }
    }

    // Check for image fill
    const blipFill = bg?.['p:bgPr']?.[0]?.['a:blipFill']?.[0];
    if (blipFill) {
      const blip = blipFill?.['a:blip']?.[0];
      const rId = blip?.$?.['r:embed'];
      
      if (rId) {
        const relationships = this.slideRelationships.get(`slide${slideNumber}`);
        const filename = relationships?.get(rId);
        const imageData = filename ? this.mediaFiles.get(filename) : undefined;
        
        if (imageData) {
          return {
            type: 'image',
            value: imageData,
            imageData,
          };
        }
      }
    }

    return undefined;
  }

  /**
   * Parse images from shapes
   */
  private async parseImages(shapes: any, slideNumber: number): Promise<ParsedSlide['images']> {
    const images: ParsedSlide['images'] = [];
    const pics = shapes?.['p:pic'] || [];

    for (let i = 0; i < pics.length; i++) {
      const pic = pics[i];
      const blipFill = pic?.['p:blipFill']?.[0];
      const blip = blipFill?.['a:blip']?.[0];
      const rId = blip?.$?.['r:embed'];

      if (rId) {
        const relationships = this.slideRelationships.get(`slide${slideNumber}`);
        const filename = relationships?.get(rId);
        const imageData = filename ? this.mediaFiles.get(filename) : undefined;

        if (imageData) {
          const spPr = pic?.['p:spPr']?.[0];
          const position = this.extractPosition(spPr);
          const rotation = this.extractRotation(spPr);

          images.push({
            id: `pptx-image-${slideNumber}-${i}`,
            imageData,
            x: position.x,
            y: position.y,
            width: position.width,
            height: position.height,
            rotation,
          });
        }
      }
    }

    return images;
  }

  /**
   * Parse text boxes from shapes
   */
  private parseTextBoxes(shapes: any): ParsedSlide['textBoxes'] {
    const textBoxes: ParsedSlide['textBoxes'] = [];
    const sps = shapes?.['p:sp'] || [];

    for (let i = 0; i < sps.length; i++) {
      const sp = sps[i];
      const txBody = sp?.['p:txBody']?.[0];
      
      if (!txBody) continue;

      // Extract text content
      const paragraphs = txBody?.['a:p'] || [];
      const textParts: string[] = [];
      let fontSize: number | undefined;
      let fontFamily: string | undefined;
      let color: string | undefined;
      let bold = false;
      let italic = false;
      let align: 'left' | 'center' | 'right' = 'left';

      for (const para of paragraphs) {
        const runs = para?.['a:r'] || [];
        
        // Get paragraph alignment
        const pPr = para?.['a:pPr']?.[0];
        if (pPr?.$?.algn) {
          const algn = pPr.$.algn;
          if (algn === 'ctr') align = 'center';
          else if (algn === 'r') align = 'right';
          else align = 'left';
        }

        for (const run of runs) {
          const text = run?.['a:t']?.[0];
          if (text) {
            textParts.push(text);
          }

          // Extract formatting from first run
          if (!fontSize) {
            const rPr = run?.['a:rPr']?.[0];
            if (rPr) {
              // Font size in points * 100 (e.g., 1200 = 12pt)
              if (rPr.$.sz) {
                fontSize = parseInt(rPr.$.sz) / 100;
              }
              
              // Font family
              const latin = rPr?.['a:latin']?.[0];
              if (latin?.$?.typeface) {
                fontFamily = latin.$.typeface;
              }

              // Bold/Italic
              if (rPr.$.b === '1') bold = true;
              if (rPr.$.i === '1') italic = true;

              // Color
              const solidFill = rPr?.['a:solidFill']?.[0];
              if (solidFill) {
                color = this.extractColor(solidFill);
              }
            }
          }
        }
      }

      const content = textParts.join(' ');
      if (!content.trim()) continue;

      const spPr = sp?.['p:spPr']?.[0];
      const position = this.extractPosition(spPr);
      const rotation = this.extractRotation(spPr);

      textBoxes.push({
        id: `pptx-text-${i}`,
        content,
        x: position.x,
        y: position.y,
        width: position.width,
        height: position.height,
        fontSize,
        fontFamily,
        color,
        bold,
        italic,
        align,
        rotation,
      });
    }

    return textBoxes;
  }

  /**
   * Parse videos from shapes
   */
  private async parseVideos(shapes: any, slideNumber: number): Promise<ParsedSlide['videos']> {
    const videos: ParsedSlide['videos'] = [];
    
    // Videos are often embedded as p:pic with video link
    const pics = shapes?.['p:pic'] || [];

    for (let i = 0; i < pics.length; i++) {
      const pic = pics[i];
      const nvPicPr = pic?.['p:nvPicPr']?.[0];
      const videoFile = nvPicPr?.['p:nvPr']?.[0]?.['a:videoFile'];

      if (videoFile) {
        const rId = videoFile?.[0]?.$?.['r:link'];
        
        if (rId) {
          const relationships = this.slideRelationships.get(`slide${slideNumber}`);
          const filename = relationships?.get(rId);
          const videoData = filename ? this.mediaFiles.get(filename) : undefined;

          if (videoData) {
            const spPr = pic?.['p:spPr']?.[0];
            const position = this.extractPosition(spPr);

            videos.push({
              id: `pptx-video-${slideNumber}-${i}`,
              videoData,
              x: position.x,
              y: position.y,
              width: position.width,
              height: position.height,
            });
          }
        }
      }
    }

    return videos;
  }

  /**
   * Extract position and size from shape properties
   */
  private extractPosition(spPr: any): { x: number; y: number; width: number; height: number } {
    const xfrm = spPr?.['a:xfrm']?.[0];
    const off = xfrm?.['a:off']?.[0]?.$;
    const ext = xfrm?.['a:ext']?.[0]?.$;

    return {
      x: parseInt(off?.x || '0'),
      y: parseInt(off?.y || '0'),
      width: parseInt(ext?.cx || '0'),
      height: parseInt(ext?.cy || '0'),
    };
  }

  /**
   * Extract rotation from shape properties
   */
  private extractRotation(spPr: any): number | undefined {
    const xfrm = spPr?.['a:xfrm']?.[0];
    const rot = xfrm?.$?.rot;
    
    if (rot) {
      // Rotation is in 60,000ths of a degree
      return parseInt(rot) / 60000;
    }
    
    return undefined;
  }

  /**
   * Extract color from fill element
   */
  private extractColor(fill: any): string | undefined {
    // Try srgbClr (RGB color)
    const srgbClr = fill?.['a:srgbClr']?.[0];
    if (srgbClr?.$?.val) {
      return `#${srgbClr.$.val}`;
    }

    // Try schemeClr (theme color) - map to common colors
    const schemeClr = fill?.['a:schemeClr']?.[0];
    if (schemeClr?.$?.val) {
      const scheme = schemeClr.$.val;
      // Map common scheme colors
      const schemeMap: Record<string, string> = {
        'bg1': '#ffffff',
        'bg2': '#f0f0f0',
        'tx1': '#000000',
        'tx2': '#333333',
        'accent1': '#4472c4',
        'accent2': '#ed7d31',
        'accent3': '#a5a5a5',
        'accent4': '#ffc000',
      'accent5': '#5b9bd5',
      'accent6': '#70ad47',
    };
    return schemeMap[scheme] || '#000000';
  }

  return undefined;
}

/**
 * Parse XML string to DOM Document using browser's native parser
 */
private parseXml(xml: string): Document {
  const parser = new DOMParser();
  const doc = parser.parseFromString(xml, 'text/xml');
  
  // Check for parse errors
  const parserError = doc.querySelector('parsererror');
  if (parserError) {
    throw new Error(`XML Parse Error: ${parserError.textContent}`);
  }
  
  return doc;
}

/**
 * Helper to get attribute value from XML element
 */
private getAttr(element: Element | null, attrName: string): string | undefined {
  if (!element) return undefined;
  return element.getAttribute(attrName) || undefined;
}

/**
 * Helper to get first child element by tag name
 */
private getFirstChild(element: Element | Document, tagName: string): Element | null {
  return element.querySelector(tagName);
}

/**
 * Helper to get all child elements by tag name
 */
private getChildren(element: Element | Document, tagName: string): Element[] {
  return Array.from(element.querySelectorAll(tagName));
}

/**
 * Helper to get text content from element
 */
private getText(element: Element | null): string {
  return element?.textContent?.trim() || '';
}

/**
 * Convert Uint8Array to base64
 */
private uint8ArrayToBase64(bytes: Uint8Array): string {
  let binary = '';
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
}

export const pptxParserService = new PptxParserService();